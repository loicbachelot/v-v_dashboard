name: deploy-dev

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Image tag to build/push (optional; defaults to commit SHA)"
        required: false
  push:
    branches: [ci/test]

permissions:
  contents: read

env:
  AWS_REGION: us-east-2

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write   # required for OIDC

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: "20"

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install CDK deps
        run: |
          python -m pip install --upgrade pip
          pip install -r cdk/requirements.txt

      # OIDC: assume the deploy role (no long-lived keys)
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::818214664804:role/GitHubActionsDeployRole
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: gha-deploy

      - name: Get AWS account id
        id: aws
        run: echo "id=$(aws sts get-caller-identity --query Account --output text)" >> "$GITHUB_OUTPUT"

      - name: Ensure ECR repos exist (idempotent)
        run: |
          aws ecr describe-repositories --repository-names v-v_dashboard >/dev/null 2>&1 || aws ecr create-repository --repository-name v-v_dashboard
          aws ecr describe-repositories --repository-names vv-lambda-upload >/dev/null 2>&1 || aws ecr create-repository --repository-name vv-lambda-upload

      - name: ECR login
        run: |
          aws ecr get-login-password --region "$AWS_REGION" \
          | docker login --username AWS --password-stdin ${{ steps.aws.outputs.id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - uses: docker/setup-buildx-action@v3

      # Build & push the Dash app image
      - name: Build & push app image
        env:
          TAG: ${{ inputs.tag || github.sha }}
          REG: ${{ steps.aws.outputs.id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
        run: |
          docker build -t v-v_dashboard:"$TAG" .
          docker tag  v-v_dashboard:"$TAG" "$REG"/v-v_dashboard:"$TAG"
          docker tag  v-v_dashboard:"$TAG" "$REG"/v-v_dashboard:2.1.14
          docker push "$REG"/v-v_dashboard:"$TAG"
          docker push "$REG"/v-v_dashboard:2.1.14

      # For Lambda: force classic builder so manifest is Docker v2 (Lambda-compatible)
      - name: Build & push lambda image (Docker v2 manifest)
        env:
          TAG: ${{ inputs.tag || github.sha }}
          REG: ${{ steps.aws.outputs.id }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
          DOCKER_BUILDKIT: 0
        run: |
          docker build -t vv-lambda-upload:"$TAG" -f lambda_process_uploads/Dockerfile lambda_process_uploads
          docker tag  vv-lambda-upload:"$TAG" "$REG"/vv-lambda-upload:"$TAG"
          docker tag  vv-lambda-upload:"$TAG" "$REG"/vv-lambda-upload:2.0.17
          docker push "$REG"/vv-lambda-upload:"$TAG"
          docker push "$REG"/vv-lambda-upload:2.0.17

      - name: CDK bootstrap (idempotent)
        run: |
          npx cdk@2 bootstrap aws://$(aws sts get-caller-identity --query Account --output text)/${AWS_REGION} || true

      - name: CDK deploy (dev)
        run: npx cdk@2 deploy --all --require-approval never

      - name: Smoke test (ALB + APIs)
        env:
          STACK: DashboardStack
        run: |
          set -euo pipefail

          # 1) Fetch outputs
          ALB=$(aws cloudformation describe-stacks --stack-name "$STACK" \
            --query "Stacks[0].Outputs[?contains(OutputKey, 'ServiceURL')].OutputValue" --output text)
          API_BASES=$(aws cloudformation describe-stacks --stack-name "$STACK" \
            --query "Stacks[0].Outputs[?contains(OutputKey, 'APIEndpoint')].OutputValue" --output text)

          echo "ALB:  $ALB"
          echo "APIs: $API_BASES"

          echo "Checking ALB..."
          curl -fsS --max-time 20 "$ALB" >/dev/null

          any_api_ok=0
          echo "Checking API health routes (auto-discovered)..."
          for base in $API_BASES; do
            b="${base%/}"  # strip trailing /
            host=$(echo "$b" | sed -E 's#^https?://([^/]+)/.*#\1#')
            api_id="${host%%.*}"

            # Try REST (v1) first
            v1_id=$(aws apigateway get-rest-apis --query "items[?id=='$api_id'].id" --output text 2>/dev/null || true)
            routes=""
            if [ -n "$v1_id" ] && [ "$v1_id" != "None" ]; then
              routes=$(aws apigateway get-resources --rest-api-id "$api_id" --embed methods \
                --query "items[?resourceMethods.GET].path" --output text 2>/dev/null || true)
            else
              # Try HTTP API / WebSocket (v2)
              v2_id=$(aws apigatewayv2 get-apis --query "Items[?ApiId=='$api_id'].ApiId" --output text 2>/dev/null || true)
              if [ -n "$v2_id" ] && [ "$v2_id" != "None" ]; then
                routes=$(aws apigatewayv2 get-routes --api-id "$api_id" \
                  --query "Items[?starts_with(RouteKey,'GET') || starts_with(RouteKey,'ANY')].RouteKey" \
                  --output text 2>/dev/null | tr '\t' '\n' | awk '{print $2}' || true)
              fi
            fi

            # Normalize and prioritize candidate paths
            candidates=""
            if [ -n "$routes" ] && [ "$routes" != "None" ]; then
              norm=$(echo "$routes" | tr '\t' '\n' | sed 's#^/*#/#' | sort -u)
              # Prefer status/health/ping if present
              preferred=$(echo "$norm" | grep -Ei '/(status|health|ping)(/)?$' || true)
              if [ -n "$preferred" ]; then
                candidates="$preferred"
              else
                candidates="$norm"
              fi
            else
              # Fallback guesses if we couldn't list routes
              candidates="/status /health /ping /file/status /api/status /"
            fi

            ok=0
            for p in $candidates; do
              url="$b${p#/}"   # ensure single slash join
              code=$(curl -sS -o /dev/null -w "%{http_code}" --max-time 20 "$url" || true)
              echo "  $url -> $code"
              if [ "$code" = "200" ] || [ "$code" = "204" ]; then
                ok=1; break
              fi
            done

            if [ $ok -eq 1 ]; then
              any_api_ok=1
            else
              echo "::warning::No 2xx health route found for base $b (tried: $candidates)"
            fi
          done

          if [ "$any_api_ok" -ne 1 ] && [ -n "$API_BASES" ]; then
            echo "Smoke test: no API base responded with 2xx."
            exit 1
          fi

          echo "Smoke test passed."


